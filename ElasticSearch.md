底层是对lucene的封装

倒排索引

将所有请求都封装成了rest api

put请求：（索引名（'数据库名称'）/类型名('表名称')/几号数据）
    第一次发送数据为新增，之后发送相同数据时为更新操作，版本号为当前版本号+1
    如果不携带id发送数据，请求方式不允许

    更新：
    （索引名/类型名/几号数据）
    {
        "name":"张三",
        "age":18,
        "phone": "123456789"
    }

post请求：（索引/类型/几号数据）
    第一次发送请求为新增，之后发送相同数据时为更新操作，版本号为当前版本号+1
    （索引/类型/）
    每次发送请求都为新增操作，每次有一个唯一id

    更新：
    （索引名/类型名/几号数据/_update）
        {
            "doc": {
                "name": "张三",
                "age": 18,
            }
        }
        当跟新数据与愿数据一致时，所有数据都不会改变（result返回数据为"noop"）

get请求：（索引/类型/几号数据）
    查询指定id的数据
    {
        "_index": "索引名称",
        "_type": "类型名称",
        "_id": "数据id",
        "_version": "版本号",
        "_seq_no": "序列号", // 并发控制字段，跟新时+1，用来做乐观锁
        "_primary_term": "主键", // 做集群中使用，主分片发生变化，该字段变化
        "found": true,
        "_source": {      // 查询到的数据
            "name": "张三",
            "age": 18,
        }
    }

    ** 为了保证数据的安全行，在修改时需要先查询，然后携带序列号与主键再修改，这样可以保证数据的安全性（索引名/类型名/几号数据/?if_seq_no=xx&if_primary_term=xxx） **

delete请求：
    删除指定id数据不存在时：（索引名/类型名/几号数据）
    {
        "found": false,
        "_index": "索引名称",
        "_type": "类型名称",
        "_id": "数据id",
    }

    删除索引：（索引名）

post /_bulk  批量导入数据
https://raw.githubusercontent.com/elastic/elasticsearch/7.4/docs/src/test/resources/accounts.json



