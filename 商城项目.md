1.项目创建

对每个服务分别创建模块，最后聚合在一个整体模块中

![image-20220205232041432](E:\File\Study\Note\picture\商城项目\image-20220205232041432.png)

父项目`pom.xml`文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.xf</groupId>
    <artifactId>MallPro</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <description>商城项目聚合服务</description>
    <name>MallPro</name>

    <modules>
        <module>coupon</module>
        <module>member</module>
        <module>order</module>
        <module>product</module>
        <module>warehousing</module>
        <module>common</module>
        <module>renren-fast</module>
        <module>renren-generator</module>
    </modules>
</project>
```

2.数据库初始化

`电商项目不要使用外键，当数据量过大时，要对每条数据进行外键检查，耗费资源`



3.项目逆向工程

使用人人开源代码生成对项目进行生成



4.整合mybatispluse

导入依赖

```
<dependency>
	<groupId>com.baomidou</groupId>
	<artifactId>mybatis-plus-boot-start</artifactId>
	<version></version>
</dependency>
```

配置数据源

```
// 导入数据库驱动
<dependency>
    <groupId>mysql</groupId>
	<artifactId>mysql-commector-java</artifactId>
	<version></version>
</dependency>

// 配置数据源（.yml）
spring:
	datasource:
		username: 
		password:
		url: jdbc:mysql:///
		driver-class-name: com.mysql.jdbc.Driver
```

配置myabtis-Pluse

```
使用MapperScan扫描Mapper接口
@MapperScan("。。。。dao")
// 告诉mybatis-plus映射文件在哪里
mybatis-plus:
	mapper-locations: classpath*:/
// 主键自增
	global-config:
		db-config:
			id-type: auto 
```

5.其他jar

`servlet`



6.微服务搭建

微服务：注册中心（Nacos），配置中心（Nacos），负载均衡（Ribbon），服务容错（Sentinel），api网关（Gateway），声明式Http客户端（Feign）

1) spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

```
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
	<version></version>
</dependency>
```

2. 配置文件中配置 Nacos Server 地址

```
 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

3. 使用 @EnableDiscoveryClient 注解开启服务注册与发现功能
4. 在每个服务中设置对相应的名字`spring.application.name: `

`完成上述步骤后，从127.0.0.1:8848/nacos中就能将该服务注册到nacos中`

nacos启动后不是本机ip地址问题

`修改config/application.properties文件，指定IP地址启动nacos.inetutils.ip-address=127.0.0.1`

## Nacos作为注册中心

**openFeign远程调用**

feign是一个**声明式**的HTTP客户端，让远程调用更加简单，Feign提供了HTTP请求的模板，**通过编写简单的接口和插入注解**，就能定义HTTP请求参数、格式、地址等。Feign整合了Ribbon（负载均衡）和Hystrix（服务熔断），让我们不再显示使用这两个组件。

1. 使用

引入依赖：

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <version></version>
</dependency>
```

编写接口，让springCloud明白需要调用远程服务

```
/**
* 这是一个远程声明式接口
*/
@FeignClient("远程服务名")
public interface FeignService{
	// 声明接口中的方法调用那个服务的那个请求
	@RequestMapping("/请求方法")
	public void method();
}
```

在启动类中使用`@EnableFeignClients(basePackages="feign所在的目录")`开启远程调用功能



2. 问题

   启动nacos后，服务启动异常`com.alibaba.nacos.api.exception.NacosException: Request nacos server failed:`

   A：将nacos启动项中启动模式改为`set MODE="standalone"`

   启动服务`No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-loadbalancer`

   A：需要引入jar包

   ```
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-loadbalancer</artifactId>
       <version>3.1.0</version>
   </dependency>
   ```

3. 引入spring-cloud-stater-loadbalacer后nacos中的ribbon造成loadbalancer失效

   A：

   ```
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        	<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-loadbalancer</artifactId>
        <version>2.2.2.RELEASE</version>
    </dependency>
   
   ```



## Nacos作为配置中心

将配置交给配置中心(本地使用bootstrap.properties文件)

1.引入依赖

```
 <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
     <version></version>
 </dependency>
```

2.在bootstrap.properties中配置Nacos config元数据

`bootstrap.properties会高于application.properties进行加载`

```properties
 # 命名空间名字
 spring.application.name=nacos-config-example 
 spring.cloud.nacos.config.server-addr=127.0.0.1:8848
```

3.获取动态配置信息

```
@RefreshScope：添加在controller中，动态获取并刷新配置
@Value("${配置项的名}")：获取到配置
```

`如果配置中心和当前应用的配置文件又相同配置，优先使用配置中心配置`

4.在nacos配置中心中添加配置信息：

```
dataId is serviceName.properties
group is DEFAULT_GROUP
```





**命名空间与配置集**

命名空间：做配置隔离（可用来区分开发环境）

​	默认为public（保留空间），默认新增的所有配置都在public空间

​	1、开发，测试，生产，利用命名空间做环境隔离

​		在bootstrap.properties：配置中，需要使用那个命名空间的配置为：

​		`spring.cloud.nacos.config.namespace=nacos配置列表中每个环境的id`

​	2、基于每个微服务之间相互隔离，每个微服务使用自己的命名空间，只加载自己的命名空间下的配置



配置集：

​	一个配置文件中所有配置的集合



配置集ID：

​	类似于配置文件名字

​	在nacos中为配置的Data ID



配置分组：

​	nacos中的GROUP；默认的配置集都属于DEFAULT_GROUP

​	`指定使用分组配置文件：spring.cloud.nacos.config.group=`



使用多个命名空间

-- 第n个

`spring.cloud.nacos.config.ext-config[第n个].data-id=配置文件名字`

`spring.cloud.nacos.config.ex-config[第n个].group=选择那个组`

`spring.cloud.nacos.config.ext-config[第n个].refresh =是否动态刷新`



使用微服务开发时，可将所有配置放在nacos中，本地只保留bootstrap.properties文件即可



## 网关（Gateway）

作为流量的入口，常用来转发，权限校验，限流控制等

1.添加模块，引入依赖

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

// 依赖公共模块
...
```

2.开启服务注册发现

`@EnableDiscoveryClient`

配置nacos注册中心地址

```
# nacos元数据
spring.application.name=gateway
spring.cloud.nacos.config.server-addr=127.0.0.1:8848

spring.cloud.nacos.config.namespace=da5337fb-2cbe-474d-8425-485f157a9fc9


# 加载nacos中其他数据集
spring.cloud.nacos.config.extension-configs[0].data-id=application.yml
spring.cloud.nacos.config.extension-configs[0].group=dev
spring.cloud.nacos.config.extension-configs[0].refresh=true
```







## 前端

**ES6**

ECMAScript6.0，是javaScript语言的下一代标准。ECMAScript是浏览器脚本语言的规范，js则是规范的具体实现 

```
let与var

let又严格作用域，不能多次申明变量
var会越域，可多次申明变量

const申明的是只读常量，不可修改
```

箭头函数

```
// 以前申明方法
var print=function(obj){
	console.log(obj);
}
// 箭头
var print = obj => console.log(obj);
var print2 = (a,b) => console.log(a+b);
```

对象优化

```
// 获取对象的键值对
Object,keys(obj)
Object,values(obj)
// 将对象转为数组
Object,entries(obj)

// 对象合并
Object.assign(目标对象，需要赋值的对象...)

// 声明对象简写
const name=xx
const age=12
const person={name:name,age:age}
// 当属性与申明变量一致时
const persion={name,age}

// 对象函数属性简写
let person = {
	name:'xxx',
	eat:function(food){
		console.log(this.name+'吃'+food)
	},
	// 箭头函数中this使用无效，需要用'对象.属性'获取数据
	sport:play=>console.log(person.name+"在玩"+play)
}

//对象扩展运算符
// 拷贝对象
let person = {name:'xxx',age:31}
let otherperson = {...person}
// 合并对象
let age = 23
let name = 'fff'
let person={...age, ...name}

```

map与reduce

```
map();接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回
reduce();为数组中的每一个元素执行回调函数，不过阔数组中被删除或从未被赋值的元素
```



**Vue**

```
MVVM思想：
M:model，包括数据和一些基本操作
V:View，视图，页面渲染结果
VM:View-Model，模型与视图间的双向操作，
```

安装（vue的模块化开发）

```
1.全局安装webpack
npm install webpack -g

2.全局安装vue脚手架
npm install -g @vue/cli-init

3.初始化vue项目（使用vue初始化一个appname项目）
vue init webpakc appname
```







### 问题

1.测试类找不到service

`启动类与测试类的目录结构需要一致，不一致时在测试类中@SpringBootTest后加入启动类字节码文件`

2.数据库longblob类型java使用byte接收
